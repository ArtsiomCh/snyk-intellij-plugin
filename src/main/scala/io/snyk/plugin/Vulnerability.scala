package io.snyk.plugin

import java.time.ZonedDateTime

import io.circe.{Decoder, JsonObject}


case class Semver(
  vulnerable: String,
  unaffected: String
)

case class MavenModuleName(
  groupId: String,
  artifactId: String
)

case class Vulnerability(
  title            : String,
  credit           : Seq[String],
  description      : String,
  moduleName       : String,
  language         : String,
  packageManager   : String,
  semver           : Semver,
  identifiers      : Map[String, Seq[String]],
  CVSSv2           : Option[String],
  severity         : String,
  creationTime     : String,
  modificationTime : String,
  publicationTime  : String,
  disclosureTime   : String,
  id               : String,
  mavenModuleName  : MavenModuleName,
  CVSSv3           : String,
  packageName      : String,
  cvssScore        : Float,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean,
)

case class FilteredVulnerability(
  title            : String,
  credit           : Seq[String],
  description      : String,
  moduleName       : String,
  language         : String,
  packageManager   : String,
  semver           : Semver,
  identifiers      : Map[String, Seq[String]],
  CVSSv2           : Option[String],
  severity         : String,
  creationTime     : ZonedDateTime,
  modificationTime : ZonedDateTime,
  publicationTime  : ZonedDateTime,
  disclosureTime   : ZonedDateTime,
  id               : String,
  mavenModuleName  : MavenModuleName,
  CVSSv3           : String,
  packageName      : String,
  cvssScore        : Float,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean,
  filtered         : VulnFilteredInfo
)

case class IgnoredBy(
  id    : String,
  name  : String,
  email : String
)

case class VulnIgnoredInfo(
  reason             : String,
  created            : String,
  expires            : String,
  ignoredBy          : IgnoredBy,
  reasonType         : String,
  disregardIfFixable : Boolean,
  source             : String,
  path               : Seq[String]
)

case class VulnFilteredInfo(ignored: Seq[VulnIgnoredInfo])

case class LicensesPolicy(severities: Map[String, String])

case class TopLevelFilteredInfo(
  ignore: Seq[FilteredVulnerability],
  patch:  Seq[JsonObject]
)

case class SnykVulnResponse(
  ok               : Boolean,
  vulnerabilities  : Seq[Vulnerability],
  dependencyCount  : Int,
  org              : String,
  licensesPolicy   : Option[LicensesPolicy],
  isPrivate        : Boolean,
  packageManager   : String,
  policy           : String,
  ignoreSettings   : Option[Map[String, Boolean]],
  summary          : String,
  filesystemPolicy : Option[Boolean],
  filtered         : Option[TopLevelFilteredInfo],
  uniqueCount      : Option[Int],
  path             : Option[String]
)

object SnykVulnResponse {
  object Decoders extends io.circe.java8.time.TimeInstances {
    import io.circe.derivation._

    implicit def decodeEither[A,B](implicit a: Decoder[A], b: Decoder[B]): Decoder[Either[A,B]] = {
      val l: Decoder[Either[A,B]] = a.map(Left.apply)
      val r: Decoder[Either[A,B]] = b.map(Right.apply)
      l or r
    }

    // We wse semi-auto derivation from circe-deriving here instead of fully-auto derivation from circe-generic
    // On the down-side, it means that we actually have to write some code, but in exchange it gives us
    // *significantly* faster compilation and we get a smaller plugin by removing remove some transitive deps
    // (including shapeless)
    //
    // If these 10 lines of code (at time of writing) ever *truly* become a problem,
    // we can switch to circe-magnolia-derivation

    implicit val decoderVulnIgnoredBy         : Decoder[IgnoredBy]             = deriveDecoder
    implicit val decoderVulnIgnoredInfo       : Decoder[VulnIgnoredInfo]       = deriveDecoder
    implicit val decoderVulnFilteredInfo      : Decoder[VulnFilteredInfo]      = deriveDecoder
    implicit val decoderLicensesPolicy        : Decoder[LicensesPolicy]        = deriveDecoder
    implicit val decoderMavenModuleName       : Decoder[MavenModuleName]       = deriveDecoder
    implicit val decoderSemver                : Decoder[Semver]                = deriveDecoder
    implicit val decoderVulnerability         : Decoder[Vulnerability]         = deriveDecoder
    implicit val decoderFilteredVulnerability : Decoder[FilteredVulnerability] = deriveDecoder
    implicit val decoderTopLevelFilteredInfo  : Decoder[TopLevelFilteredInfo]  = deriveDecoder
    implicit val decoderSnykVulnResponse      : Decoder[SnykVulnResponse]      = deriveDecoder
  }
}



