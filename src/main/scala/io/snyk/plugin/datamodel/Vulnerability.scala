package io.snyk.plugin.datamodel

import io.circe.derivation.{deriveDecoder, deriveEncoder}
import io.circe.{Decoder, Encoder, JsonObject}
import cats.syntax.functor._


case class Semver(vulnerable: Seq[String])

case class MavenModuleName(
  groupId: String,
  artifactId: String
)

sealed trait Vulnerability

case class SecurityVuln(
  title            : String,
  credit           : Seq[String],
  description      : String,
  moduleName       : String,
  language         : String,
  packageManager   : String,
  semver           : Semver,
  identifiers      : Map[String, Seq[String]],
  CVSSv2           : Option[String],
  severity         : String,
  creationTime     : String,
  modificationTime : String,
  publicationTime  : String,
  disclosureTime   : String,
  id               : String,
  mavenModuleName  : MavenModuleName,
  CVSSv3           : String,
  packageName      : String,
  cvssScore        : Float,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean,
  filtered         : Option[VulnFilteredInfo]
) extends Vulnerability {
  /**
    * @return A combined string of the Snyk ID and CWE ID (if present)
    */
  def combinedId: String = {
    val cwe = identifiers.get("CWE").flatMap(_.headOption).filterNot(_.isEmpty)
    val cweSuffix = cwe.map(" (" + _ + ")").getOrElse("")
    s"$id$cweSuffix"
  }

  /**
    * @return A sequence of just the String components in the upgrade path, or "n/a"
    */
  def normalisedUpgradePath: Seq[String] =
    if(isUpgradable) { upgradePath.flatMap(_.right.toSeq) } else Seq("n/a")

  def toMiniVuln: MiniVuln = MiniVuln from this
}

case class LicenseVuln(
  title            : String,
  description      : String,
  language         : String,
  packageManager   : String,
  packageName      : String,
  semver           : Semver,
  severity         : String,
  creationTime     : String,
  publicationTime  : String,
  id               : String,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean
) extends Vulnerability

case class IgnoredBy(
  id    : String,
  name  : String,
  email : String
)

object IgnoredBy {
  implicit val encoder: Encoder[IgnoredBy] = deriveEncoder
  implicit val decoder: Decoder[IgnoredBy] = deriveDecoder
}

case class VulnIgnoredInfo(
  reason             : String,
  created            : String,
  expires            : String,
  ignoredBy          : IgnoredBy,
  reasonType         : String,
  disregardIfFixable : Boolean,
  source             : String,
  path               : Seq[String]
)

object VulnIgnoredInfo {
  implicit val encoder: Encoder[VulnIgnoredInfo] = deriveEncoder
  implicit val decoder: Decoder[VulnIgnoredInfo] = deriveDecoder
}

case class VulnFilteredInfo(ignored: Seq[VulnIgnoredInfo])

object VulnFilteredInfo {
  implicit val encoder: Encoder[VulnFilteredInfo] = deriveEncoder
  implicit val decoder: Decoder[VulnFilteredInfo] = deriveDecoder
}

case class LicensesPolicy(severities: Map[String, String])

case class TopLevelFilteredInfo(
  ignore: Seq[Vulnerability],
  patch:  Seq[JsonObject]
)

case class SnykVulnResponse(
  ok               : Boolean,
  vulnerabilities  : Seq[Vulnerability],
  dependencyCount  : Int,
  org              : String,
  licensesPolicy   : Option[LicensesPolicy],
  isPrivate        : Boolean,
  packageManager   : String,
  policy           : String,
  ignoreSettings   : Option[Map[String, Boolean]],
  summary          : String,
  filesystemPolicy : Option[Boolean],
  filtered         : Option[TopLevelFilteredInfo],
  uniqueCount      : Option[Int],
  path             : Option[String]
) {
  def ignoredVulnerabilities: Seq[Vulnerability] = filtered.toSeq.flatMap(_.ignore)

  lazy val securityVulns: Seq[SecurityVuln] =
    vulnerabilities collect { case sv: SecurityVuln => sv }

  lazy val ignoredSecurityVulns: Seq[SecurityVuln] =
    ignoredVulnerabilities collect { case sv: SecurityVuln => sv }

  lazy val flatMiniVulns: Seq[MiniVuln] = {
    //    val vulns: Seq[MiniVuln] = (securityVulns.map(MiniVuln.from) ++ ignoredVulnerabilities.map(MiniVuln.from)).distinct
    securityVulns.map(MiniVuln.from).distinct
  }

  lazy val mergedMiniVulns: Seq[MiniVuln] = {
    MiniVuln.merge(flatMiniVulns)
  }

  def isEmpty: Boolean = this eq SnykVulnResponse.empty
}

object SnykVulnResponse {
  val empty: SnykVulnResponse = SnykVulnResponse(
    ok               = true,
    vulnerabilities  = Nil,
    dependencyCount  = 0,
    org              = "",
    licensesPolicy   = None,
    isPrivate        = false,
    packageManager   = "",
    policy           = "",
    ignoreSettings   = None,
    summary          = "",
    filesystemPolicy = None,
    filtered         = None,
    uniqueCount      = None,
    path             = None
  )

  object Decoders extends io.circe.java8.time.TimeInstances {
    import io.circe.derivation._
    import io.circe.syntax._

    implicit def decodeEither[A,B](implicit a: Decoder[A], b: Decoder[B]): Decoder[Either[A,B]] = {
      val l: Decoder[Either[A,B]] = a.map(Left.apply)
      val r: Decoder[Either[A,B]] = b.map(Right.apply)
      l or r
    }

    implicit def encodeEither[A, B](implicit a: Encoder[A], b: Encoder[B]): Encoder[Either[A, B]] = {
      o: Either[A, B] => o.fold(_.asJson, _.asJson)
    }

    // We wse semi-auto derivation from circe-deriving here instead of fully-auto derivation from circe-generic
    // On the down-side, it means that we actually have to write some code, but in exchange it gives us
    // *significantly* faster compilation and we get a smaller plugin by removing remove some transitive deps
    // (including shapeless)
    //
    // If these 10 lines of code (at time of writing) ever *truly* become a problem,
    // we can switch to circe-magnolia-derivation

    implicit val decoderVulnIgnoredBy         : Decoder[IgnoredBy]             = deriveDecoder
    implicit val decoderVulnIgnoredInfo       : Decoder[VulnIgnoredInfo]       = deriveDecoder
    implicit val decoderVulnFilteredInfo      : Decoder[VulnFilteredInfo]      = deriveDecoder
    implicit val decoderLicensesPolicy        : Decoder[LicensesPolicy]        = deriveDecoder
    implicit val decoderMavenModuleName       : Decoder[MavenModuleName]       = deriveDecoder
    implicit val decoderSemver                : Decoder[Semver]                = deriveDecoder

    implicit val decoderSecurityVuln          : Decoder[SecurityVuln]          = deriveDecoder
    implicit val decoderLicenseVuln           : Decoder[LicenseVuln]           = deriveDecoder

    implicit val decoderVulnerability: Decoder[Vulnerability] =
      decoderSecurityVuln.widen or decoderLicenseVuln.widen

    implicit val decoderTopLevelFilteredInfo  : Decoder[TopLevelFilteredInfo]  = deriveDecoder
    implicit val decoderSnykVulnResponse      : Decoder[SnykVulnResponse]      = deriveDecoder

    implicit val encoderVulnIgnoredBy         : Encoder[IgnoredBy]             = deriveEncoder
    implicit val encoderVulnIgnoredInfo       : Encoder[VulnIgnoredInfo]       = deriveEncoder
    implicit val encoderVulnFilteredInfo      : Encoder[VulnFilteredInfo]      = deriveEncoder
    implicit val encoderLicensesPolicy        : Encoder[LicensesPolicy]        = deriveEncoder
    implicit val encoderMavenModuleName       : Encoder[MavenModuleName]       = deriveEncoder
    implicit val encoderSemver                : Encoder[Semver]                = deriveEncoder

    implicit val encoderSecurityVuln          : Encoder[SecurityVuln]          = deriveEncoder
    implicit val encoderLicenseVuln           : Encoder[LicenseVuln]           = deriveEncoder

    implicit val encoderVulnerability: Encoder[Vulnerability] = Encoder.instance {
      case sec: SecurityVuln => sec.asJson
      case lic: LicenseVuln => lic.asJson
    }

    implicit val encoderTopLevelFilteredInfo  : Encoder[TopLevelFilteredInfo]  = deriveEncoder
    implicit val encoderSnykVulnResponse      : Encoder[SnykVulnResponse]      = deriveEncoder
  }
}



