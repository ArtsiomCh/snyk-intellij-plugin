package io.snyk.plugin.model

import java.time.ZonedDateTime

import io.circe.{Decoder, JsonObject}


case class Semver(
  vulnerable: String,
  unaffected: String
) {
  def splitVulnerable: Seq[String] = {
    var inBlock = false
    var partial = new StringBuilder("")
    var outSeq = Seq.newBuilder[String]

    val OpenBracket = """(\[|\()""".r  // literal [ or ( in single match group
    val CloseBracket = """(\]|\))""".r // literal ] or ) in single match group

    vulnerable foreach {
      case OpenBracket(ch) =>
        partial += ch
        inBlock = true
      case CloseBracket(ch) =>
        partial += ch
        outSeq += partial.result()
        partial.clear()
        inBlock = false
      case ch if !inBlock => //do nowt
      case ch if  inBlock => partial += ch
    }
    outSeq.result()
  }
}

case class MavenModuleName(
  groupId: String,
  artifactId: String
)

case class Vulnerability(
  title            : String,
  credit           : Seq[String],
  description      : String,
  moduleName       : String,
  language         : String,
  packageManager   : String,
  semver           : Semver,
  identifiers      : Map[String, Seq[String]],
  CVSSv2           : Option[String],
  severity         : String,
  creationTime     : String,
  modificationTime : String,
  publicationTime  : String,
  disclosureTime   : String,
  id               : String,
  mavenModuleName  : MavenModuleName,
  CVSSv3           : String,
  packageName      : String,
  cvssScore        : Float,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean,
) {
  /**
    * @return A combined string of the Snyk ID and CWE ID (if present)
    */
  def combinedId: String = {
    val cwe = identifiers.get("CWE").flatMap(_.headOption).filterNot(_.isEmpty)
    val cweSuffix = cwe.map(" (" + _ + ")").getOrElse("")
    s"$id$cweSuffix"
  }

  /**
    * @return A sequence of just the String components in the upgrade path, or "n/a"
    */
  def normalisedUpgradePath: Seq[String] =
    if(isUpgradable) { upgradePath.flatMap(_.right.toSeq) } else Seq("n/a")

  def toMiniVuln: MiniVuln = MiniVuln(
    title        = this.title,
    id           = this.id,
    moduleName   = this.moduleName,
    severity     = this.severity,
    versions     = this.semver.splitVulnerable,
    isUpgradable = this.isUpgradable,
    isPatchable  = this.isPatchable,
    isIgnored    = false
  )
}

case class FilteredVulnerability(
  title            : String,
  credit           : Seq[String],
  description      : String,
  moduleName       : String,
  language         : String,
  packageManager   : String,
  semver           : Semver,
  identifiers      : Map[String, Seq[String]],
  CVSSv2           : Option[String],
  severity         : String,
  creationTime     : ZonedDateTime,
  modificationTime : ZonedDateTime,
  publicationTime  : ZonedDateTime,
  disclosureTime   : ZonedDateTime,
  id               : String,
  mavenModuleName  : MavenModuleName,
  CVSSv3           : String,
  packageName      : String,
  cvssScore        : Float,
  from             : Seq[String],
  upgradePath      : Seq[Either[Boolean, String]],
  version          : String,
  name             : String,
  isUpgradable     : Boolean,
  isPatchable      : Boolean,
  filtered         : VulnFilteredInfo
) {
  def toMiniVuln: MiniVuln = MiniVuln(
    title        = this.title,
    id           = this.id,
    moduleName   = this.moduleName,
    severity     = this.severity,
    versions     = this.semver.splitVulnerable,
    isUpgradable = this.isUpgradable,
    isPatchable  = this.isPatchable,
    isIgnored    = true
  )
}

case class IgnoredBy(
  id    : String,
  name  : String,
  email : String
)

case class VulnIgnoredInfo(
  reason             : String,
  created            : String,
  expires            : String,
  ignoredBy          : IgnoredBy,
  reasonType         : String,
  disregardIfFixable : Boolean,
  source             : String,
  path               : Seq[String]
)

case class VulnFilteredInfo(ignored: Seq[VulnIgnoredInfo])

case class LicensesPolicy(severities: Map[String, String])

case class TopLevelFilteredInfo(
  ignore: Seq[FilteredVulnerability],
  patch:  Seq[JsonObject]
)

case class SnykVulnResponse(
  ok               : Boolean,
  vulnerabilities  : Seq[Vulnerability],
  dependencyCount  : Int,
  org              : String,
  licensesPolicy   : Option[LicensesPolicy],
  isPrivate        : Boolean,
  packageManager   : String,
  policy           : String,
  ignoreSettings   : Option[Map[String, Boolean]],
  summary          : String,
  filesystemPolicy : Option[Boolean],
  filtered         : Option[TopLevelFilteredInfo],
  uniqueCount      : Option[Int],
  path             : Option[String]
) {
  lazy val miniVulns: Seq[MiniVuln] = {
    vulnerabilities.map(_.toMiniVuln) ++ filtered.toSeq.flatMap(_.ignore.map(_.toMiniVuln))
  }
}

object SnykVulnResponse {
  val empty: SnykVulnResponse = SnykVulnResponse(
    ok               = true,
    vulnerabilities  = Nil,
    dependencyCount  = 0,
    org              = "",
    licensesPolicy   = None,
    isPrivate        = false,
    packageManager   = "",
    policy           = "",
    ignoreSettings   = None,
    summary          = "",
    filesystemPolicy = None,
    filtered         = None,
    uniqueCount      = None,
    path             = None
  )

  object Decoders extends io.circe.java8.time.TimeInstances {
    import io.circe.derivation._

    implicit def decodeEither[A,B](implicit a: Decoder[A], b: Decoder[B]): Decoder[Either[A,B]] = {
      val l: Decoder[Either[A,B]] = a.map(Left.apply)
      val r: Decoder[Either[A,B]] = b.map(Right.apply)
      l or r
    }

    // We wse semi-auto derivation from circe-deriving here instead of fully-auto derivation from circe-generic
    // On the down-side, it means that we actually have to write some code, but in exchange it gives us
    // *significantly* faster compilation and we get a smaller plugin by removing remove some transitive deps
    // (including shapeless)
    //
    // If these 10 lines of code (at time of writing) ever *truly* become a problem,
    // we can switch to circe-magnolia-derivation

    implicit val decoderVulnIgnoredBy         : Decoder[IgnoredBy]             = deriveDecoder
    implicit val decoderVulnIgnoredInfo       : Decoder[VulnIgnoredInfo]       = deriveDecoder
    implicit val decoderVulnFilteredInfo      : Decoder[VulnFilteredInfo]      = deriveDecoder
    implicit val decoderLicensesPolicy        : Decoder[LicensesPolicy]        = deriveDecoder
    implicit val decoderMavenModuleName       : Decoder[MavenModuleName]       = deriveDecoder
    implicit val decoderSemver                : Decoder[Semver]                = deriveDecoder
    implicit val decoderVulnerability         : Decoder[Vulnerability]         = deriveDecoder
    implicit val decoderFilteredVulnerability : Decoder[FilteredVulnerability] = deriveDecoder
    implicit val decoderTopLevelFilteredInfo  : Decoder[TopLevelFilteredInfo]  = deriveDecoder
    implicit val decoderSnykVulnResponse      : Decoder[SnykVulnResponse]      = deriveDecoder
  }
}



